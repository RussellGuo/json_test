//
// Created by ubuntu on 2023/8/22.
//
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include "../host/uart_io_api.h"
#include "../host/serial_datagram.h"
#include "ALog.h"

/* Header for class com_huaqin_serialport_SerialPort */

#ifndef _Included_com_huaqin_serialport_SerialPort
#define _Included_com_huaqin_serialport_SerialPort

#ifdef __cplusplus
extern "C" {
#endif


JavaVM *g_VM;
jobject g_obj;




/*
 * Class:     com_huaqin_serialport_SerialPort
 * Method:    initUart
 * Signature: ()Z
 */

JNIEXPORT jboolean JNICALL Java_com_huaqin_serialport_SerialPort_initUart
        (JNIEnv *, jobject){
    bool ret;
    ret = init_uart_io_api();
    return ret;
}

/*
 * Class:     com_huaqin_serialport_SerialPort
 * Method:    serialDatagramSend
 * Signature: ()Z
 */
JNIEXPORT jboolean JNICALL Java_com_huaqin_serialport_SerialPort_serialDatagramSend
        (JNIEnv *, jclass){
    bool bet;
    bet = serial_datagram_send(123, 0x08, NULL, 0);
    return bet;
}

//在此处跑在子线程中，并回调到java层
void download(void *p) {
    JNIEnv *env;

    //获取当前native线程是否有没有被附加到jvm环境中
    int getEnvStat = (*g_VM)->GetEnv(g_VM, (void **) &env,JNI_VERSION_1_6);
    int mNeedDetach;
    if (getEnvStat == JNI_EDETACHED) {
        //如果没有， 主动附加到jvm环境中，获取到env
        if ((*g_VM)->AttachCurrentThread(g_VM, &env, NULL) != 0) {
            return;
        }
        mNeedDetach = JNI_TRUE;
    }

    //通过全局变量g_obj 获取到要回调的类
    jclass javaClass = (*env)->GetObjectClass(env, g_obj);

    if (javaClass == 0) {
        LOGD("Unable to find class");
        (*g_VM)->DetachCurrentThread(g_VM);
        return;
    }

    //获取要回调的方法ID
    jmethodID javaCallbackId = (*env)->GetMethodID(env, javaClass,
                                                   "onNativeCallBack", "(JJ)I");
    if (javaCallbackId == NULL) {
        LOGD("Unable to find method:onProgressCallBack");
        return;
    }
    //执行回调
    (*env)->CallIntMethod(env, g_obj, javaCallbackId,1,1);

    //释放当前线程
    if(mNeedDetach) {
        (*g_VM)->DetachCurrentThread(g_VM);
    }
    env = NULL;
}

/*
 * Class:     com_huaqin_serialport_SerialPort
 * Method:    serialDatagramReceiveLoop
 * Signature: ()Z
 */
void JNICALL Java_com_huaqin_serialport_SerialPort_serialDatagramReceiveLoop
        (JNIEnv *env, jobject object){
    LOGD("Java_com_huaqin_serialport_SerialPort_serialDatagramReceiveLoop");
    //serial_datagram_receive_loop(0);
   //JavaVM是虚拟机在JNI中的表示，等下再其他线程回调java层需要用到
    (*env)->GetJavaVM(env, &g_VM);
    // 生成一个全局引用保留下来，以便回调
    g_obj = (*env)->NewGlobalRef(env, object);
    pthread_t ntid;
    // 此处使用c语言开启一个线程，进行回调，这时候java层就不会阻塞，只是在等待回调
    pthread_create(ntid,NULL, download,NULL);


}



#ifdef __cplusplus
}
#endif
#endif
